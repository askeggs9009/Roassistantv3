<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoAssistant - Dashboard</title>
    <link rel="icon" type="image/png" href="/roassistant-logo.png">

    <!-- Organization Structured Data for Google Search -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "url": "https://www.roassistant.me",
      "logo": "https://www.roassistant.me/roassistant-logo.png",
      "name": "RoAssistant",
      "description": "AI-powered Roblox development assistant"
    }
    </script>

    <link rel="stylesheet" href="styles/liquid-glass.css">
    <link rel="stylesheet" href="styles/dot-grid.css">
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/sidebar.css">
    <link rel="stylesheet" href="styles/chat.css">
    <link rel="stylesheet" href="styles/animations.css">
    <link rel="stylesheet" href="styles/responsive.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        /* Subscription Status Styles */
        .subscription-status {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 1rem;
            background: rgba(33, 38, 45, 0.6);
            border: 1px solid #30363d;
            border-radius: 8px;
            margin-right: 1rem;
        }

        .plan-badge {
            background: linear-gradient(45deg, #58a6ff, #1f6feb);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .plan-badge.free {
            background: linear-gradient(45deg, #8b949e, #6e7681);
        }

        .plan-badge.pro {
            background: linear-gradient(45deg, #58a6ff, #1f6feb);
        }

        .plan-badge.enterprise {
            background: linear-gradient(45deg, #9d4edd, #7c3aed);
        }

        /* Project Context Styles */
        .project-files-info {
            background: rgba(88, 166, 255, 0.1);
            border: 1px solid rgba(88, 166, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        .welcome-content a {
            color: #58a6ff;
            text-decoration: none;
        }

        .welcome-content a:hover {
            text-decoration: underline;
        }

        .usage-counter {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #8b949e;
            font-size: 0.85rem;
        }

        .usage-bar {
            width: 100px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .usage-fill {
            height: 100%;
            background: linear-gradient(90deg, #58a6ff, #1f6feb);
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .usage-fill.warning {
            background: linear-gradient(90deg, #d4ac0d, #f39c12);
        }

        .usage-fill.danger {
            background: linear-gradient(90deg, #e74c3c, #c0392b);
        }

        /* Roblox Connection Status Styles */
        .roblox-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.8rem;
            background: rgba(33, 38, 45, 0.6);
            border: 1px solid #30363d;
            border-radius: 8px;
            font-size: 0.85rem;
            margin-right: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .roblox-status:hover {
            background: rgba(33, 38, 45, 0.8);
            border-color: #484f58;
        }

        .roblox-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .roblox-status-dot.connected {
            background: #57f287;
            box-shadow: 0 0 8px rgba(87, 242, 135, 0.6);
        }

        .roblox-status-dot.disconnected {
            background: #ed4245;
            box-shadow: 0 0 8px rgba(237, 66, 69, 0.6);
        }

        .roblox-status-text {
            color: #8b949e;
            font-weight: 500;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Send to Roblox Button */
        .send-to-roblox-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            transition: all 0.2s ease;
            margin-left: 0.5rem;
        }

        .send-to-roblox-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }

        .send-to-roblox-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .send-to-roblox-btn i {
            font-size: 0.9rem;
        }

        .usage-fill.danger {
            background: linear-gradient(90deg, #f85149, #da3633);
        }

        /* Explorer Panel Styles */
        .explorer-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 300px;
            height: 100vh;
            background: rgba(22, 27, 34, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid #30363d;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease, right 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .explorer-panel.hidden {
            transform: translateX(100%);
        }

        /* Shift Explorer left when code panel is open */
        body.code-panel-open .explorer-panel {
            right: 50%;
        }

        .explorer-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            border-bottom: 1px solid #30363d;
            background: rgba(33, 38, 45, 0.6);
        }

        .explorer-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            font-weight: 600;
            color: #c9d1d9;
        }

        .explorer-title i {
            color: #58a6ff;
        }

        .explorer-refresh, .explorer-toggle {
            background: transparent;
            border: none;
            color: #8b949e;
            cursor: pointer;
            padding: 0.4rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .explorer-refresh:hover, .explorer-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #c9d1d9;
        }

        .explorer-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            color: #8b949e;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid #30363d;
        }

        .explorer-status i {
            font-size: 0.5rem;
            color: #ed4245;
        }

        .explorer-status.connected i {
            color: #57f287;
        }

        .explorer-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .explorer-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #8b949e;
            text-align: center;
        }

        .explorer-empty i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .explorer-empty p {
            font-size: 0.9rem;
        }

        /* Explorer Tree Styles */
        .explorer-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.15s ease;
            user-select: none;
            font-size: 0.85rem;
        }

        .explorer-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .explorer-item-icon {
            width: 16px;
            text-align: center;
            flex-shrink: 0;
        }

        .explorer-item-toggle {
            color: #8b949e;
            font-size: 0.7rem;
            width: 12px;
            flex-shrink: 0;
        }

        .explorer-item-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .explorer-item-name {
            color: #c9d1d9;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .explorer-item-class {
            color: #8b949e;
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .explorer-children {
            margin-left: 1rem;
            border-left: 1px solid rgba(255, 255, 255, 0.05);
            padding-left: 0.5rem;
        }

        .explorer-children.collapsed {
            display: none;
        }

        /* Icon colors for different instance types */
        .icon-script { color: #58a6ff; }
        .icon-localscript { color: #79c0ff; }
        .icon-modulescript { color: #f85149; }
        .icon-folder { color: #8b949e; }
        .icon-part { color: #57f287; }
        .icon-model { color: #d2a8ff; }
        .icon-screengui { color: #f0883e; }
        .icon-default { color: #8b949e; }

        /* Adjust main content when explorer is visible */
        .main-content.explorer-visible {
            margin-right: 300px;
        }

        /* Script Viewer Modal */
        .script-viewer-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .script-viewer-modal.active {
            display: flex;
        }

        .script-viewer-content {
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #30363d;
            border-radius: 12px;
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .script-viewer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #30363d;
            background: rgba(33, 38, 45, 0.6);
            border-radius: 12px 12px 0 0;
        }

        .script-viewer-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: #c9d1d9;
        }

        .script-viewer-title i {
            color: #58a6ff;
        }

        .script-viewer-close {
            background: transparent;
            border: none;
            color: #8b949e;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 1.2rem;
        }

        .script-viewer-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #c9d1d9;
        }

        .script-viewer-body {
            padding: 1.5rem;
            overflow-y: auto;
            flex: 1;
        }

        .script-viewer-body pre {
            margin: 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
        }

        .script-viewer-body code {
            color: #c9d1d9;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Make script items clickable */
        .explorer-item.script-item {
            cursor: pointer;
        }

        .explorer-item.script-item:hover {
            background: rgba(88, 166, 255, 0.15);
        }

        .explorer-item.script-item:hover .explorer-item-name {
            color: #58a6ff;
        }

        /* Project Selector Styles */
        .project-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.8rem;
            background: rgba(33, 38, 45, 0.6);
            border: 1px solid #30363d;
            border-radius: 8px;
            margin-right: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .project-selector:hover {
            background: rgba(33, 38, 45, 0.8);
            border-color: #484f58;
        }

        .project-selector-icon {
            color: #58a6ff;
            font-size: 0.9rem;
        }

        .project-selector-text {
            color: #c9d1d9;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .project-selector-arrow {
            color: #8b949e;
            font-size: 0.7rem;
            margin-left: 0.25rem;
        }

        .project-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            min-width: 250px;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .project-dropdown.active {
            display: block;
        }

        .project-dropdown-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #30363d;
            font-weight: 600;
            color: #c9d1d9;
            font-size: 0.85rem;
        }

        .project-dropdown-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.2s ease;
            border-bottom: 1px solid rgba(48, 54, 61, 0.3);
        }

        .project-dropdown-item:last-child {
            border-bottom: none;
        }

        .project-dropdown-item:hover {
            background: rgba(88, 166, 255, 0.1);
        }

        .project-dropdown-item.active {
            background: rgba(88, 166, 255, 0.2);
            border-left: 3px solid #58a6ff;
        }

        .project-dropdown-name {
            color: #c9d1d9;
            font-weight: 500;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .project-dropdown-desc {
            color: #8b949e;
            font-size: 0.75rem;
        }

        .project-dropdown-footer {
            padding: 0.75rem 1rem;
            border-top: 1px solid #30363d;
        }

        .project-dropdown-create {
            width: 100%;
            padding: 0.5rem;
            background: linear-gradient(45deg, #238636, #2ea043);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .project-dropdown-create:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(46, 160, 67, 0.4);
        }

        /* Search Results Modal */
        .search-results-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .search-results-modal.active {
            display: flex;
        }

        .search-results-content {
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #30363d;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .search-results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #30363d;
            background: rgba(33, 38, 45, 0.6);
            border-radius: 12px 12px 0 0;
        }

        .search-results-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: #c9d1d9;
        }

        .search-results-title i {
            color: #58a6ff;
        }

        .search-results-close {
            background: transparent;
            border: none;
            color: #8b949e;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 1.2rem;
        }

        .search-results-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #c9d1d9;
        }

        .search-results-body {
            padding: 1rem;
            overflow-y: auto;
            flex: 1;
        }

        .search-result-item {
            background: rgba(33, 38, 45, 0.6);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-result-item:hover {
            background: rgba(88, 166, 255, 0.1);
            border-color: #58a6ff;
            transform: translateX(4px);
        }

        .search-result-name {
            font-weight: 600;
            color: #c9d1d9;
            font-size: 1rem;
            margin-bottom: 0.25rem;
        }

        .search-result-creator {
            font-size: 0.85rem;
            color: #8b949e;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .search-result-creator i {
            font-size: 0.75rem;
        }

        .search-results-empty {
            text-align: center;
            padding: 2rem;
            color: #8b949e;
        }

        .search-results-empty i {
            font-size: 3rem;
            opacity: 0.3;
            margin-bottom: 1rem;
        }
    </style>
</head>

<body>
    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <img src="roassistant-logo.png" alt="RoAssistant Logo" class="sidebar-logo" style="width: 40px; height: 40px; object-fit: contain;">
            <div class="sidebar-title">RoAssistant</div>
        </div>

        <button class="new-chat-btn" onclick="startNewChat()">
            <span>+</span>
            New chat
        </button>

        <div class="sidebar-nav">
            <!-- Main Navigation -->
            <div class="nav-section">
                <div class="nav-item active" onclick="window.location.href='/index.html'">
                    <span class="nav-icon"><i class="fas fa-comments"></i></span>
                    Chats
                </div>
                <div class="nav-item" onclick="window.location.href='/projects.html'">
                    <span class="nav-icon"><i class="fas fa-folder"></i></span>
                    Projects
                </div>
                <div class="nav-item" onclick="window.location.href='/scripts.html'">
                    <span class="nav-icon"><i class="fas fa-wrench"></i></span>
                    Scripts
                </div>
                <div class="nav-item authenticated-only" onclick="window.location.href='/account.html'" style="color: #8b949e;">
                    <span class="nav-icon">⚙️</span>
                    Account
                </div>
                <div class="nav-item" onclick="window.location.href='/pricing.html'" style="color: #58a6ff;">
                    <span class="nav-icon"><i class="fas fa-gem"></i></span>
                    Upgrade Plan
                </div>
            </div>

            <!-- Recent Chats -->
            <div class="nav-section">
                <div class="nav-title">Recents</div>
                <div id="chatHistory">
                    <!-- Chat history will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <div class="sidebar-footer">
            <div class="user-profile" id="userProfile">
                <!-- Default Sign In button - will be replaced by JavaScript -->
                <div class="user-avatar"><i class="fas fa-user"></i></div>
                <div class="user-info">
                    <div class="user-name">Guest User</div>
                    <div class="user-plan">Free Plan - <span style="color: #58a6ff; cursor: pointer;" onclick="window.location.href='/login.html'">Sign In for More</span></div>
                </div>
                <button onclick="window.location.href='/login.html'" style="background: #238636; border: none; border-radius: 6px; color: white; padding: 0.4rem 0.8rem; font-size: 0.8rem; cursor: pointer; margin-left: 0.5rem;">
                    Sign In
                </button>
            </div>
        </div>
    </div>

    <!-- Code Panel (for displaying code blocks) -->
    <div class="code-panel-overlay" id="codePanel">
        <div class="code-panel-resize-handle" id="codePanelResizeHandle"></div>
        <div class="code-panel-header">
            <div class="code-panel-title">
                <i class="fas fa-code"></i>
                <span>Code Output</span>
            </div>
            <button class="code-panel-close" onclick="closeCodePanel()">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="code-panel-content" id="codePanelContent">
            <!-- Code blocks will be displayed here -->
        </div>
    </div>

    <!-- Explorer Panel -->
    <div class="explorer-panel" id="explorerPanel">
        <div class="explorer-header">
            <div class="explorer-title">
                <i class="fas fa-folder-tree"></i>
                <span>Explorer</span>
            </div>
            <button class="explorer-refresh" id="explorerRefreshBtn" title="Refresh Explorer">
                <i class="fas fa-sync-alt"></i>
            </button>
            <button class="explorer-toggle" id="explorerToggleBtn" title="Close Explorer">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="explorer-status" id="explorerStatus">
            <i class="fas fa-circle"></i>
            <span>Disconnected</span>
        </div>
        <div class="explorer-content" id="explorerContent">
            <div class="explorer-empty">
                <i class="fas fa-cube"></i>
                <p>Connect Roblox Studio to view Explorer</p>
            </div>
        </div>
    </div>

    <!-- Script Viewer Modal -->
    <div class="script-viewer-modal" id="scriptViewerModal">
        <div class="script-viewer-content">
            <div class="script-viewer-header">
                <div class="script-viewer-title">
                    <i class="fas fa-file-code"></i>
                    <span id="scriptViewerName">Script</span>
                </div>
                <button class="script-viewer-close" onclick="closeScriptViewer()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="script-viewer-body">
                <pre><code id="scriptViewerCode" class="language-lua"></code></pre>
            </div>
        </div>
    </div>

    <!-- Search Results Modal -->
    <div class="search-results-modal" id="searchResultsModal">
        <div class="search-results-content">
            <div class="search-results-header">
                <div class="search-results-title">
                    <i class="fas fa-search"></i>
                    <span id="searchResultsTitle">Search Results</span>
                </div>
                <button class="search-results-close" onclick="closeSearchResults()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="search-results-body" id="searchResultsBody">
                <div class="search-results-empty">
                    <i class="fas fa-cube"></i>
                    <p>Searching...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content" id="mainContent">
        <!-- Header -->
        <div class="main-header">
            <button class="mobile-menu-btn" id="mobileMenuBtn" onclick="toggleSidebar()">
                ☰
            </button>
            <div class="header-title" id="chatTitle">New Chat</div>

            <!-- Project Selector -->
            <div class="project-selector" id="projectSelector" style="display: none;" onclick="toggleProjectDropdown()">
                <i class="fas fa-folder project-selector-icon"></i>
                <span class="project-selector-text" id="projectSelectorText">No Project</span>
                <i class="fas fa-chevron-down project-selector-arrow"></i>

                <!-- Project Dropdown -->
                <div class="project-dropdown" id="projectDropdown">
                    <div class="project-dropdown-header">Select Project</div>
                    <div class="project-dropdown-item" onclick="event.stopPropagation(); selectProject(null)">
                        <div class="project-dropdown-name">No Project</div>
                        <div class="project-dropdown-desc">Use standalone chat mode</div>
                    </div>
                    <div id="projectDropdownList">
                        <!-- Projects will be populated here -->
                    </div>
                    <div class="project-dropdown-footer">
                        <button class="project-dropdown-create" onclick="event.stopPropagation(); window.location.href='/projects.html'">
                            <i class="fas fa-plus"></i> Create New Project
                        </button>
                    </div>
                </div>
            </div>

            <!-- Subscription Status -->
            <div class="subscription-status" id="subscriptionStatus" style="display: none;">
                <a href="/account.html" style="text-decoration: none;">
                    <div class="plan-badge" id="planBadge" style="cursor: pointer; transition: transform 0.2s ease;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'" title="View Account Details">Free</div>
                </a>
                <div class="usage-counter">
                    <span id="usageText">0/10</span>
                    <div class="usage-bar">
                        <div class="usage-fill" id="usageFill" style="width: 0%;"></div>
                    </div>
                </div>
            </div>

            <!-- Roblox Connection Status -->
            <div class="roblox-status" id="robloxStatus" title="Click to check connection">
                <div class="roblox-status-dot disconnected" id="robloxStatusDot"></div>
                <span class="roblox-status-text" id="robloxStatusText">Roblox Studio</span>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="chat-area">
            <div class="messages-container" id="messagesContainer">
                <!-- Welcome Screen -->
                <div class="welcome-screen stagger-animation" id="welcomeScreen">
                    <div class="welcome-icon"><i class="fas fa-rocket"></i></div>
                    <h1 class="welcome-title" data-text="Welcome to RoAssistant">Welcome to RoAssistant</h1>
                    <p class="welcome-subtitle">Your intelligent assistant for Roblox game development</p>
                </div>
            </div>

            <!-- Input Area -->
            <div class="input-container">
                <div class="input-wrapper" id="inputWrapper">
                    <div class="input-content">
                        <!-- File attachments area -->
                        <div class="file-attachments" id="fileAttachments" style="display: none;"></div>

                        <!-- Roblox Studio Connection Status -->
                        <div class="roblox-status-banner" style="padding: 10px 16px; display: flex; align-items: center; gap: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); background: rgba(88, 101, 242, 0.05);">
                            <i class="fas fa-cube" style="font-size: 16px; color: #5865f2;"></i>
                            <div style="flex: 1;">
                                <div style="font-size: 13px; color: rgba(255,255,255,0.9); font-weight: 500;">Roblox Studio Connection</div>
                                <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 2px;">Auto-sends Lua scripts to connected Studio</div>
                            </div>
                            <div id="robloxStatusBanner" style="display: flex; align-items: center; gap: 8px; padding: 6px 12px; background: rgba(0,0,0,0.2); border-radius: 12px;">
                                <div id="robloxStatusDotBanner" style="width: 10px; height: 10px; border-radius: 50%; background: #666;"></div>
                                <span id="robloxStatusTextBanner" style="font-size: 12px; font-weight: 500;">Checking...</span>
                            </div>
                        </div>

                        <!-- Credit counter -->
                        <div id="creditCounter" style="
                            font-size: 12px;
                            color: #8b949e;
                            margin-bottom: 8px;
                            text-align: right;
                            display: none;
                        ">
                            <span id="creditCounterText">0 / 10 credits used today</span>
                        </div>

                        <!-- Input row -->
                        <div class="input-row">
                            <!-- Model selector removed - auto-selects based on plan -->

                            <textarea
                                class="input-area"
                                id="messageInput"
                                placeholder="Ask me about your project..."
                                rows="1"
                            ></textarea>
                            <button class="send-button" id="sendButton" onclick="sendMessage()">
                                <span>Send</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DYNAMIC API CONFIGURATION
        const getApiBaseUrl = () => {
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                return 'http://localhost:3000';
            }
            return 'https://roassistantv3-production.up.railway.app';
        };

        const API_BASE_URL = getApiBaseUrl();
        console.log(`[CONFIG] Using API Base URL: ${API_BASE_URL}`);

        // Global variables
        let selectedModel = 'claude-4-sonnet';
        window.selectedModel = selectedModel;
        let currentProject = null;
        let currentChatName = 'New Chat';
        let projects = [];

        // Check URL for project parameter
        function loadProjectFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const projectId = urlParams.get('project');

            if (projectId) {
                // Load project from localStorage
                const storedProjects = JSON.parse(localStorage.getItem('roblox_projects') || '[]');
                const project = storedProjects.find(p => p.id === projectId);

                if (project) {
                    selectProject(project);
                } else {
                    console.log('Project not found:', projectId);
                }
            }

            // Load all projects for dropdown
            loadProjects();
        }

        // Load all projects
        function loadProjects() {
            projects = JSON.parse(localStorage.getItem('roblox_projects') || '[]');

            if (projects.length > 0) {
                // Show project selector
                document.getElementById('projectSelector').style.display = 'flex';

                // Populate dropdown
                const dropdownList = document.getElementById('projectDropdownList');
                dropdownList.innerHTML = projects.map(project => `
                    <div class="project-dropdown-item ${currentProject && currentProject.id === project.id ? 'active' : ''}"
                         onclick="event.stopPropagation(); selectProjectById('${project.id}')">
                        <div class="project-dropdown-name">${project.name}</div>
                        <div class="project-dropdown-desc">${project.description || 'No description'}</div>
                    </div>
                `).join('');
            }
        }

        // Toggle project dropdown
        function toggleProjectDropdown() {
            const dropdown = document.getElementById('projectDropdown');
            dropdown.classList.toggle('active');
        }

        // Select project by ID
        function selectProjectById(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (project) {
                selectProject(project);
            }
        }

        // Select project
        function selectProject(project) {
            currentProject = project;

            // Update URL
            const url = new URL(window.location);
            if (project) {
                url.searchParams.set('project', project.id);
                document.getElementById('projectSelectorText').textContent = project.name;
            } else {
                url.searchParams.delete('project');
                document.getElementById('projectSelectorText').textContent = 'No Project';
            }
            window.history.pushState({}, '', url);

            // Update chat manager
            if (window.chatManager) {
                window.chatManager.currentProject = project;
            }

            // Update title
            updateChatTitle();

            // Close dropdown
            document.getElementById('projectDropdown').classList.remove('active');

            // Start new chat with project context
            startNewChat();
        }

        // Update chat title
        function updateChatTitle() {
            const chatTitle = document.getElementById('chatTitle');
            if (!chatTitle) return;

            if (currentProject) {
                const artifactCount = currentProject.artifacts?.length || 0;
                const artifactInfo = artifactCount > 0 ?
                    `<span style="color: #58a6ff; font-size: 0.85rem; margin-left: 0.5rem;">(${artifactCount} artifact${artifactCount !== 1 ? 's' : ''})</span>` : '';

                chatTitle.innerHTML = `
                    <span style="color: #8b949e;">${currentProject.name}</span>
                    <span style="color: #484f58; margin: 0 0.25rem;">/</span>
                    <span>${currentChatName}</span>
                    ${artifactInfo}
                `;
            } else {
                chatTitle.textContent = currentChatName;
            }
        }

        // Update chat name
        window.updateChatName = function(newName) {
            currentChatName = newName || 'New Chat';
            updateChatTitle();
        }

        // Global sendMessage wrapper
        function sendMessage() {
            if (window.chatManager) {
                window.chatManager.sendMessage();
            } else {
                console.error('ChatManager not initialized');
            }
        }

        // Toggle model selector dropdown
        function toggleModelSelector() {
            const dropdown = document.getElementById('modelDropdown');
            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        }

        // Select a model
        function selectModel(model) {
            selectedModel = model;
            window.selectedModel = selectedModel;

            // Update selected state in dropdown
            document.querySelectorAll('.model-option').forEach(option => {
                option.classList.remove('selected');
                const check = option.querySelector('.model-check');
                if (check) {
                    check.style.display = 'none';
                }
            });

            const selectedOption = document.querySelector(`.model-option[data-model="${model}"]`);
            if (selectedOption) {
                selectedOption.classList.add('selected');
                const check = selectedOption.querySelector('.model-check');
                if (check) {
                    check.style.display = 'block';
                }
            }

            // Start a new chat when model changes
            startNewChat();

            // Show a message indicating the model change
            const modelName = model === 'claude-4-opus' ? 'RoCode Nexus 3' : 'RoCode 3';
            if (window.chatManager) {
                window.chatManager.addMessage('system', `🔄 Switched to ${modelName}. Starting a new conversation.`);
            }

            // Hide dropdown
            document.getElementById('modelDropdown').style.display = 'none';
        }

        // Start new chat
        function startNewChat() {
            currentChatName = 'New Chat';
            updateChatTitle();
            if (window.chatManager) {
                window.chatManager.startNewChat();
            }
        }

        // Toggle sidebar
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('active');
        }

        // ============================================
        // ROBLOX AUTO-SEND FUNCTIONALITY
        // ============================================

        let robloxConnected = false;
        let sentCodeBlocks = new Set();

        // Structured script parser (from RoConsole)
        function parseStructuredScripts(response) {
            const scripts = [];
            // Updated regex to capture optional properties attribute
            const scriptRegex = /<roblox_script\s+name="([^"]+)"\s+type="([^"]+)"\s+location="([^"]+)"(?:\s+properties='([^']*)')?>([\s\S]*?)<\/roblox_script>/gi;

            let match;
            while ((match = scriptRegex.exec(response)) !== null) {
                const [, name, type, location, properties, code] = match;

                const script = {
                    name: name.trim(),
                    type: type.trim(),
                    location: location.trim(),
                    code: code.trim(),
                    id: `structured_${Date.now()}_${scripts.length}`
                };

                // Parse properties if present
                if (properties) {
                    try {
                        script.properties = JSON.parse(properties);
                        console.log(`[Parser] Found properties for ${name}:`, script.properties);
                    } catch (error) {
                        console.warn(`[Parser] Failed to parse properties for ${name}:`, error);
                    }
                }

                scripts.push(script);

                console.log(`[Parser] Found structured script: ${name} (${type}) -> ${location}`);
            }

            return scripts;
        }

        // Parse edit commands from AI response
        function parseEditCommands(response) {
            const edits = [];
            // Regex to capture edit commands: <roblox_edit target="path" properties='{}'>code</roblox_edit>
            const editRegex = /<roblox_edit\s+target="([^"]+)"(?:\s+properties='([^']*)')?>([\s\S]*?)<\/roblox_edit>/gi;

            let match;
            while ((match = editRegex.exec(response)) !== null) {
                const [, target, properties, code] = match;

                const edit = {
                    target: target.trim(),
                    code: code.trim() || null,
                    id: `edit_${Date.now()}_${edits.length}`
                };

                // Parse properties if present
                if (properties) {
                    try {
                        edit.properties = JSON.parse(properties);
                        console.log(`[Parser] Found edit properties for ${target}:`, edit.properties);
                    } catch (error) {
                        console.warn(`[Parser] Failed to parse edit properties for ${target}:`, error);
                    }
                }

                edits.push(edit);

                console.log(`[Parser] Found edit command: ${target}`);
            }

            return edits;
        }

        function parseDeleteCommands(response) {
            const deletes = [];
            // Regex to capture delete commands: <roblox_delete target="path" /> or <roblox_delete target="path"></roblox_delete>
            const deleteRegex = /<roblox_delete\s+target="([^"]+)"(?:\s*\/>|><\/roblox_delete>)/gi;

            let match;
            while ((match = deleteRegex.exec(response)) !== null) {
                const [, target] = match;

                const deleteCmd = {
                    target: target.trim(),
                    id: `delete_${Date.now()}_${deletes.length}`
                };

                deletes.push(deleteCmd);

                console.log(`[Parser] Found delete command: ${target}`);
            }

            return deletes;
        }

        // Parse search commands from AI response
        function parseSearchCommands(response) {
            const searches = [];
            // Regex to capture search commands: <roblox_search query="search terms" />
            const searchRegex = /<roblox_search\s+query="([^"]+)"(?:\s*\/>|><\/roblox_search>)/gi;

            let match;
            while ((match = searchRegex.exec(response)) !== null) {
                const [, query] = match;

                const searchCmd = {
                    query: query.trim(),
                    id: `search_${Date.now()}_${searches.length}`
                };

                searches.push(searchCmd);

                console.log(`[Parser] Found search command: ${query}`);
            }

            return searches;
        }

        function getScriptType(type) {
            const typeMap = {
                'Script': 'Script',
                'LocalScript': 'LocalScript',
                'ModuleScript': 'ModuleScript',
                'ScreenGui': 'Instance',
                'Frame': 'Instance',
                'TextButton': 'Instance',
                'TextLabel': 'Instance',
                'TextBox': 'Instance',
                'ImageLabel': 'Instance',
                'ImageButton': 'Instance',
                'ScrollingFrame': 'Instance',
                'Folder': 'Instance',
                'RemoteEvent': 'Instance',
                'RemoteFunction': 'Instance',
                'Part': 'Instance',
                'Model': 'Instance',
                'Tool': 'Instance',
                'MeshPart': 'Instance',
                'UnionOperation': 'Instance',
                'WedgePart': 'Instance',
                'CornerWedgePart': 'Instance'
            };

            return typeMap[type] || 'Script';
        }

        // Check Roblox connection status
        async function checkRobloxConnection() {
            try {
                const response = await fetch(`${getApiBaseUrl()}/roblox/connection-status`);
                const data = await response.json();

                robloxConnected = data.connected && data.clients > 0;

                const statusDot = document.getElementById('robloxStatusDot');
                const statusText = document.getElementById('robloxStatusText');
                const statusDotBanner = document.getElementById('robloxStatusDotBanner');
                const statusTextBanner = document.getElementById('robloxStatusTextBanner');

                if (robloxConnected) {
                    statusDot.classList.remove('disconnected');
                    statusDot.classList.add('connected');
                    statusText.textContent = 'Connected';
                    statusDotBanner.style.background = '#57f287';
                    statusTextBanner.textContent = 'Connected';
                } else {
                    statusDot.classList.remove('connected');
                    statusDot.classList.add('disconnected');
                    statusText.textContent = 'Disconnected';
                    statusDotBanner.style.background = '#ed4245';
                    statusTextBanner.textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('[Roblox] Failed to check connection:', error);
                const statusDot = document.getElementById('robloxStatusDot');
                const statusText = document.getElementById('robloxStatusText');
                const statusDotBanner = document.getElementById('robloxStatusDotBanner');
                const statusTextBanner = document.getElementById('robloxStatusTextBanner');

                statusDot.classList.remove('connected');
                statusDot.classList.add('disconnected');
                statusText.textContent = 'Error';
                statusDotBanner.style.background = '#666';
                statusTextBanner.textContent = 'Error';
            }
        }

        // Send code to Roblox Studio
        async function sendCodeToRoblox(codeBlock) {
            try {
                const scriptName = codeBlock.name || codeBlock.summary || codeBlock.id || 'GeneratedScript';
                const scriptType = codeBlock.type ? getScriptType(codeBlock.type) : 'Script';
                const location = codeBlock.location || 'ServerScriptService';
                const code = codeBlock.code || '';

                const payload = {
                    name: scriptName,
                    code: code,
                    scriptType: scriptType,
                    location: location,
                    instanceType: codeBlock.type || scriptType
                };

                // Include properties if present
                if (codeBlock.properties) {
                    payload.properties = codeBlock.properties;
                    console.log(`[Roblox] Sending with properties:`, codeBlock.properties);
                }

                const response = await fetch(`${getApiBaseUrl()}/roblox/send-script`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.success) {
                    console.log(`[Roblox] ✅ Sent ${codeBlock.type || 'script'}: ${scriptName} to ${location}`);
                    return { success: true, scriptName, location };
                } else {
                    console.error(`[Roblox] ❌ Failed to send script: ${scriptName}`);
                    return { success: false, scriptName, location };
                }
            } catch (error) {
                console.error('[Roblox] Error sending script:', error);
                return { success: false, scriptName: codeBlock.name || codeBlock.summary || 'Unknown' };
            }
        }

        // Send edit command to Roblox Studio
        async function sendEditToRoblox(edit) {
            try {
                const payload = {
                    target: edit.target,
                    code: edit.code,
                    properties: edit.properties
                };

                console.log(`[Roblox] Sending edit command for:`, edit.target);

                const response = await fetch(`${getApiBaseUrl()}/roblox/edit-object`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.success) {
                    console.log(`[Roblox] ✅ Edit sent: ${edit.target}`);
                    return { success: true, target: edit.target };
                } else {
                    console.error(`[Roblox] ❌ Failed to send edit: ${edit.target}`);
                    return { success: false, target: edit.target };
                }
            } catch (error) {
                console.error('[Roblox] Error sending edit:', error);
                return { success: false, target: edit.target };
            }
        }

        // Send edit commands
        async function sendEditCommands(edits) {
            if (!edits || edits.length === 0) {
                console.log('[Roblox] No edit commands to send');
                return;
            }

            console.log(`[Roblox] Sending ${edits.length} edit command(s)...`);

            const results = [];
            for (const edit of edits) {
                const result = await sendEditToRoblox(edit);
                results.push(result);
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            const successCount = results.filter(r => r.success).length;
            const totalCount = results.length;

            if (successCount > 0) {
                showRobloxNotification(`✅ Edited ${successCount}/${totalCount} object(s) in Roblox Studio`);
            } else {
                showRobloxNotification(`❌ Failed to edit objects in Roblox Studio`, 'error');
            }

            return results;
        }

        async function sendDeleteToRoblox(deleteCmd) {
            try {
                const payload = {
                    target: deleteCmd.target
                };

                console.log(`[Roblox] Sending delete command for:`, deleteCmd.target);

                const response = await fetch(`${getApiBaseUrl()}/roblox/delete-object`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.success) {
                    console.log(`[Roblox] ✅ Delete sent: ${deleteCmd.target}`);
                    return { success: true, target: deleteCmd.target };
                } else {
                    console.error(`[Roblox] ❌ Failed to send delete: ${deleteCmd.target}`);
                    return { success: false, target: deleteCmd.target };
                }
            } catch (error) {
                console.error('[Roblox] Error sending delete:', error);
                return { success: false, target: deleteCmd.target };
            }
        }

        // Send delete commands
        async function sendDeleteCommands(deletes) {
            if (!deletes || deletes.length === 0) {
                console.log('[Roblox] No delete commands to send');
                return;
            }

            console.log(`[Roblox] Sending ${deletes.length} delete command(s)...`);

            const results = [];
            for (const deleteCmd of deletes) {
                const result = await sendDeleteToRoblox(deleteCmd);
                results.push(result);
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            const successCount = results.filter(r => r.success).length;
            const totalCount = results.length;

            if (successCount > 0) {
                showRobloxNotification(`✅ Deleted ${successCount}/${totalCount} object(s) in Roblox Studio`);
            } else {
                showRobloxNotification(`❌ Failed to delete objects in Roblox Studio`, 'error');
            }

            return results;
        }

        // Send search command to Roblox Studio
        async function sendSearchToRoblox(searchCmd) {
            try {
                const payload = {
                    query: searchCmd.query,
                    page: 0
                };

                console.log(`[Roblox] Sending toolbox search for:`, searchCmd.query);

                const response = await fetch(`${getApiBaseUrl()}/roblox/search-toolbox`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.success) {
                    console.log(`[Roblox] ✅ Search sent: ${searchCmd.query}`);
                    showRobloxNotification(`🔍 Searching toolbox for "${searchCmd.query}"...`);

                    // Start polling for results
                    pollSearchResults(searchCmd.query);

                    return { success: true, query: searchCmd.query };
                } else {
                    console.error(`[Roblox] ❌ Failed to send search: ${searchCmd.query}`);
                    return { success: false, query: searchCmd.query };
                }
            } catch (error) {
                console.error('[Roblox] Error sending search:', error);
                return { success: false, query: searchCmd.query };
            }
        }

        // Poll for search results from backend
        async function pollSearchResults(query) {
            let attempts = 0;
            const maxAttempts = 10; // 10 seconds total

            const pollInterval = setInterval(async () => {
                try {
                    attempts++;

                    const response = await fetch(`${getApiBaseUrl()}/roblox/connection-status`);
                    const data = await response.json();

                    if (data.lastSearchResults && data.lastSearchResults.query === query) {
                        clearInterval(pollInterval);
                        showSearchResults(data.lastSearchResults);
                    }

                    if (attempts >= maxAttempts) {
                        clearInterval(pollInterval);
                        showRobloxNotification('❌ Search timed out', 'error');
                    }
                } catch (error) {
                    console.error('[Roblox] Error polling search results:', error);
                    clearInterval(pollInterval);
                }
            }, 1000);
        }

        // Show search results in modal
        function showSearchResults(results) {
            const modal = document.getElementById('searchResultsModal');
            const title = document.getElementById('searchResultsTitle');
            const body = document.getElementById('searchResultsBody');

            title.textContent = `Search: "${results.query}" (${results.totalCount} results)`;

            if (!results.models || results.models.length === 0) {
                body.innerHTML = `
                    <div class="search-results-empty">
                        <i class="fas fa-search"></i>
                        <p>No models found for "${results.query}"</p>
                    </div>
                `;
            } else {
                body.innerHTML = results.models.map(model => `
                    <div class="search-result-item" onclick="insertModelFromSearch('${model.assetId}', '${model.name.replace(/'/g, "\\'")}')">
                        <div class="search-result-name">${model.name}</div>
                        <div class="search-result-creator">
                            <i class="fas fa-user"></i>
                            <span>by ${model.creator}</span>
                        </div>
                    </div>
                `).join('');
            }

            modal.classList.add('active');
        }

        // Close search results modal
        function closeSearchResults() {
            const modal = document.getElementById('searchResultsModal');
            modal.classList.remove('active');
        }

        // Insert model from search results
        async function insertModelFromSearch(assetId, name) {
            try {
                const payload = {
                    assetId: parseInt(assetId),
                    location: 'Workspace'
                };

                console.log(`[Roblox] Inserting model: ${name} (${assetId})`);

                const response = await fetch(`${getApiBaseUrl()}/roblox/insert-model`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.success) {
                    console.log(`[Roblox] ✅ Model inserted: ${name}`);
                    showRobloxNotification(`✅ Inserted "${name}" into Workspace`);
                    closeSearchResults();
                } else {
                    console.error(`[Roblox] ❌ Failed to insert model: ${name}`);
                    showRobloxNotification(`❌ Failed to insert "${name}"`, 'error');
                }
            } catch (error) {
                console.error('[Roblox] Error inserting model:', error);
                showRobloxNotification('❌ Error inserting model', 'error');
            }
        }

        // Make closeSearchResults available globally
        window.closeSearchResults = closeSearchResults;

        // Send search commands
        async function sendSearchCommands(searches) {
            if (!searches || searches.length === 0) {
                console.log('[Roblox] No search commands to send');
                return;
            }

            console.log(`[Roblox] Sending ${searches.length} search command(s)...`);

            const results = [];
            for (const searchCmd of searches) {
                const result = await sendSearchToRoblox(searchCmd);
                results.push(result);
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            return results;
        }

        // Send structured scripts
        async function sendStructuredScripts(scripts) {
            if (!scripts || scripts.length === 0) {
                console.log('[Roblox] No structured scripts to send');
                return;
            }

            console.log(`[Roblox] Sending ${scripts.length} structured script(s)...`);

            const results = [];
            for (const script of scripts) {
                sentCodeBlocks.add(script.id);
                const result = await sendCodeToRoblox(script);
                results.push(result);
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            const successCount = results.filter(r => r.success).length;
            const totalCount = results.length;

            if (successCount > 0) {
                showRobloxNotification(`✅ Created ${successCount}/${totalCount} component(s) in Roblox Studio`);
            } else {
                showRobloxNotification(`❌ Failed to create components in Roblox Studio`, 'error');
            }

            return results;
        }

        let lastAIResponse = '';

        // Auto-send to Roblox
        async function autoSendToRoblox(fullResponse) {
            if (!robloxConnected) {
                console.log('[Roblox] Not connected to Roblox Studio');
                return;
            }

            if (fullResponse) {
                lastAIResponse = fullResponse;
            }

            // Track if we processed ANY structured commands
            let processedCommands = false;

            // Check for search commands FIRST (highest priority)
            if (lastAIResponse) {
                const searchCommands = parseSearchCommands(lastAIResponse);

                if (searchCommands.length > 0) {
                    console.log(`[Roblox] Found ${searchCommands.length} search command(s) in AI response`);
                    await sendSearchCommands(searchCommands);
                    processedCommands = true;
                }
            }

            // Check for edit commands
            if (lastAIResponse) {
                const editCommands = parseEditCommands(lastAIResponse);

                if (editCommands.length > 0) {
                    console.log(`[Roblox] Found ${editCommands.length} edit command(s) in AI response`);
                    await sendEditCommands(editCommands);
                    processedCommands = true;
                }
            }

            // Check for delete commands
            if (lastAIResponse) {
                const deleteCommands = parseDeleteCommands(lastAIResponse);

                if (deleteCommands.length > 0) {
                    console.log(`[Roblox] Found ${deleteCommands.length} delete command(s) in AI response`);
                    await sendDeleteCommands(deleteCommands);
                    processedCommands = true;
                }
            }

            // Check for structured scripts
            if (lastAIResponse) {
                const structuredScripts = parseStructuredScripts(lastAIResponse);

                if (structuredScripts.length > 0) {
                    console.log(`[Roblox] Found ${structuredScripts.length} structured script(s) in AI response`);
                    await sendStructuredScripts(structuredScripts);
                    processedCommands = true;
                }
            }

            // If we processed any structured commands, stop here - don't fall through to code block fallback
            if (processedCommands) {
                lastAIResponse = '';
                return;
            }

            // Fallback to code blocks
            if (!window._codeBlocks || Object.keys(window._codeBlocks).length === 0) {
                console.log('[Roblox] No code blocks to send');
                return;
            }

            const newBlocks = [];
            for (const blockId in window._codeBlocks) {
                if (!sentCodeBlocks.has(blockId)) {
                    newBlocks.push(window._codeBlocks[blockId]);
                    sentCodeBlocks.add(blockId);
                }
            }

            if (newBlocks.length === 0) {
                console.log('[Roblox] No new code blocks to send');
                return;
            }

            console.log(`[Roblox] Auto-sending ${newBlocks.length} NEW code block(s)...`);

            const results = [];
            for (const block of newBlocks) {
                const result = await sendCodeToRoblox(block);
                results.push(result);
            }

            const successCount = results.filter(r => r.success).length;
            const totalCount = results.length;

            if (successCount > 0) {
                showRobloxNotification(`✅ Sent ${successCount}/${totalCount} script(s) to Roblox Studio`);
            } else {
                showRobloxNotification(`❌ Failed to send scripts to Roblox Studio`, 'error');
            }
        }

        // Show notification toast
        function showRobloxNotification(message, type = 'success') {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'success' ? '#57f287' : '#ed4245'};
                color: #000;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(400px); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);

            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Setup Roblox auto-send hook
        function setupRobloxAutoSendHook() {
            checkRobloxConnection();
            setInterval(checkRobloxConnection, 5000);

            let codeBlockCheckInterval = null;
            let lastCodeBlockCount = 0;

            if (window.chatManager) {
                const originalAddMessage = window.chatManager.addMessage.bind(window.chatManager);

                window.chatManager.addMessage = function(role, content, options) {
                    const result = originalAddMessage(role, content, options);

                    if (role === 'assistant') {
                        if (codeBlockCheckInterval) {
                            clearInterval(codeBlockCheckInterval);
                        }

                        lastCodeBlockCount = 0;
                        lastAIResponse = content;

                        // Check for ANY structured commands (scripts, search, edit, delete)
                        const hasStructuredScripts = /<roblox_script\s+name="[^"]+"\s+type="[^"]+"\s+location="[^"]+">/.test(content);
                        const hasSearchCommands = /<roblox_search\s+query="[^"]+"\s*\/?>/.test(content);
                        const hasEditCommands = /<roblox_edit\s+target="[^"]+">/.test(content);
                        const hasDeleteCommands = /<roblox_delete\s+target="[^"]+"\s*\/?>/.test(content);
                        const hasAnyStructuredCommands = hasStructuredScripts || hasSearchCommands || hasEditCommands || hasDeleteCommands;

                        if (hasAnyStructuredCommands) {
                            console.log('[Roblox] Detected structured commands, will auto-send after render');
                            setTimeout(() => {
                                console.log('[Roblox] Triggering auto-send for structured commands');
                                autoSendToRoblox(content);
                            }, 500);
                            return result;
                        }

                        let checksWithoutChange = 0;
                        let hasSeenCodeBlocks = false;
                        codeBlockCheckInterval = setInterval(() => {
                            const currentCount = window._codeBlocks ? Object.keys(window._codeBlocks).length : 0;

                            if (currentCount > 0) {
                                hasSeenCodeBlocks = true;
                            }

                            if (hasSeenCodeBlocks) {
                                if (currentCount === lastCodeBlockCount) {
                                    checksWithoutChange++;

                                    if (checksWithoutChange >= 2) {
                                        clearInterval(codeBlockCheckInterval);
                                        codeBlockCheckInterval = null;
                                        console.log('[Roblox] Code blocks stable, triggering auto-send');
                                        autoSendToRoblox(content);
                                    }
                                } else {
                                    checksWithoutChange = 0;
                                    lastCodeBlockCount = currentCount;
                                }
                            }

                            if (checksWithoutChange >= 25 && hasSeenCodeBlocks) {
                                clearInterval(codeBlockCheckInterval);
                                codeBlockCheckInterval = null;
                                console.log('[Roblox] Timeout reached, sending anyway');
                                autoSendToRoblox(content);
                            }
                        }, 200);
                    }

                    return result;
                };
            }
        }

        // ============================================
        // EXPLORER PANEL FUNCTIONALITY
        // ============================================

        let explorerVisible = true;
        let explorerData = null;

        function getInstanceIcon(className) {
            const iconMap = {
                'Script': 'fas fa-file-code icon-script',
                'LocalScript': 'fas fa-file-code icon-localscript',
                'ModuleScript': 'fas fa-cube icon-modulescript',
                'Folder': 'fas fa-folder icon-folder',
                'Part': 'fas fa-cube icon-part',
                'Model': 'fas fa-cubes icon-model',
                'ScreenGui': 'fas fa-desktop icon-screengui',
                'Frame': 'fas fa-square icon-default',
                'TextButton': 'fas fa-mouse-pointer icon-default',
                'TextLabel': 'fas fa-font icon-default',
                'RemoteEvent': 'fas fa-bolt icon-default',
                'RemoteFunction': 'fas fa-bolt icon-default'
            };

            return iconMap[className] || 'fas fa-circle icon-default';
        }

        function openScriptViewer(scriptName, sourceCode) {
            const modal = document.getElementById('scriptViewerModal');
            const nameElement = document.getElementById('scriptViewerName');
            const codeElement = document.getElementById('scriptViewerCode');

            nameElement.textContent = scriptName;
            codeElement.textContent = sourceCode;

            modal.classList.add('active');
        }

        function closeScriptViewer() {
            const modal = document.getElementById('scriptViewerModal');
            modal.classList.remove('active');
        }

        window.closeScriptViewer = closeScriptViewer;

        function renderExplorerItem(item, level = 0) {
            const hasChildren = item.children && item.children.length > 0;
            const isScript = item.source && (item.className === 'Script' || item.className === 'LocalScript' || item.className === 'ModuleScript');

            const itemDiv = document.createElement('div');
            itemDiv.className = 'explorer-item-wrapper';
            itemDiv.style.marginLeft = (level * 0.5) + 'rem';

            const itemHeader = document.createElement('div');
            itemHeader.className = 'explorer-item';

            if (isScript) {
                itemHeader.classList.add('script-item');
            }

            if (hasChildren) {
                const toggle = document.createElement('span');
                toggle.className = 'explorer-item-toggle';
                toggle.innerHTML = '<i class="fas fa-chevron-down"></i>';
                itemHeader.appendChild(toggle);
            } else {
                const spacer = document.createElement('span');
                spacer.className = 'explorer-item-toggle';
                spacer.innerHTML = '';
                itemHeader.appendChild(spacer);
            }

            const icon = document.createElement('span');
            icon.className = 'explorer-item-icon';
            icon.innerHTML = `<i class="${getInstanceIcon(item.className)}"></i>`;
            itemHeader.appendChild(icon);

            const name = document.createElement('span');
            name.className = 'explorer-item-name';
            name.textContent = item.name;
            itemHeader.appendChild(name);

            const className = document.createElement('span');
            className.className = 'explorer-item-class';
            className.textContent = item.className;
            itemHeader.appendChild(className);

            itemDiv.appendChild(itemHeader);

            if (isScript) {
                itemHeader.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openScriptViewer(item.name, item.source);
                });
            }

            if (hasChildren) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'explorer-children';

                for (const child of item.children) {
                    childrenDiv.appendChild(renderExplorerItem(child, level + 1));
                }

                itemDiv.appendChild(childrenDiv);

                if (!isScript) {
                    itemHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const toggle = itemHeader.querySelector('.explorer-item-toggle i');
                        if (toggle) {
                            toggle.classList.toggle('collapsed');
                            childrenDiv.classList.toggle('collapsed');
                        }
                    });
                }
            }

            return itemDiv;
        }

        async function updateExplorerPanel() {
            try {
                const response = await fetch(`${getApiBaseUrl()}/roblox/explorer`);
                const data = await response.json();

                console.log('[Explorer] Received data:', {
                    connected: data.connected,
                    hierarchyLength: data.hierarchy ? data.hierarchy.length : 0,
                    lastUpdate: data.lastUpdate
                });

                const explorerContent = document.getElementById('explorerContent');
                const explorerStatus = document.getElementById('explorerStatus');

                if (data.connected && data.hierarchy && data.hierarchy.length > 0) {
                    explorerStatus.classList.add('connected');
                    explorerStatus.innerHTML = '<i class="fas fa-circle"></i><span>Connected</span>';

                    explorerContent.innerHTML = '';

                    for (const service of data.hierarchy) {
                        explorerContent.appendChild(renderExplorerItem(service));
                    }

                    explorerData = data.hierarchy;
                } else {
                    explorerStatus.classList.remove('connected');
                    explorerStatus.innerHTML = '<i class="fas fa-circle"></i><span>Disconnected</span>';

                    explorerContent.innerHTML = `
                        <div class="explorer-empty">
                            <i class="fas fa-cube"></i>
                            <p>Connect Roblox Studio to view Explorer</p>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('[Explorer] Failed to fetch data:', error);
            }
        }

        function toggleExplorerPanel() {
            explorerVisible = !explorerVisible;
            const panel = document.getElementById('explorerPanel');
            const mainContent = document.getElementById('mainContent');

            if (explorerVisible) {
                panel.classList.remove('hidden');
                mainContent.classList.add('explorer-visible');
            } else {
                panel.classList.add('hidden');
                mainContent.classList.remove('explorer-visible');
            }
        }

        function initializeExplorerPanel() {
            document.getElementById('scriptViewerModal').addEventListener('click', (e) => {
                if (e.target.id === 'scriptViewerModal') {
                    closeScriptViewer();
                }
            });

            document.getElementById('explorerToggleBtn').addEventListener('click', toggleExplorerPanel);

            document.getElementById('explorerRefreshBtn').addEventListener('click', () => {
                const btn = document.getElementById('explorerRefreshBtn');
                btn.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i>';

                updateExplorerPanel().then(() => {
                    setTimeout(() => {
                        btn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                    }, 500);
                });
            });

            updateExplorerPanel();
            setInterval(updateExplorerPanel, 3000);

            const mainContent = document.getElementById('mainContent');
            mainContent.classList.add('explorer-visible');
        }

        // Initialize when DOM is ready
        window.addEventListener('DOMContentLoaded', function() {
            console.log('Unified RoAssistant loaded');

            // Load project from URL if present
            loadProjectFromUrl();

            // Initialize Roblox features
            setTimeout(setupRobloxAutoSendHook, 500);
            setTimeout(initializeExplorerPanel, 100);
        });
    </script>

    <!-- Load JavaScript modules - EXACT SAME ORDER AS roconsole.html -->
    <script src="js/storage-utils.js"></script>
    <script src="js/sync-manager.js"></script>
    <script src="js/sync-ui.js"></script>
    <script src="js/auth.js"></script>
    <script src="js/chat.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/scripts.js"></script>
    <script src="js/micro-interactions.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <!-- ReactBits-Inspired Animations -->
    <script src="js/animations/dot-grid-background.js"></script>
    <script src="js/animations/blur-text.js"></script>
    <script src="js/animations/animations-init.js"></script>

    <script src="js/app.js"></script>

    <!-- Initialize the application -->
    <script>
        // Ensure openCodePanel is available globally
        if (!window.openCodePanel) {
            window.openCodePanel = function(blockId) {
                console.log('[Project Chat] openCodePanel called for:', blockId);
                if (window.chatManager && window.chatManager.openCodePanel) {
                    window.chatManager.openCodePanel(blockId);
                } else {
                    console.error('[Project Chat] ChatManager not ready, retrying...');
                    setTimeout(() => {
                        if (window.chatManager && window.chatManager.openCodePanel) {
                            window.chatManager.openCodePanel(blockId);
                        } else {
                            console.error('[Project Chat] ChatManager still not available');
                        }
                    }, 500);
                }
            };
        }

        // Close code panel function
        function closeCodePanel() {
            const codePanel = document.getElementById('codePanel');
            const mainContent = document.getElementById('mainContent');
            const explorerPanel = document.getElementById('explorerPanel');

            if (codePanel) {
                codePanel.classList.remove('active');
            }
            if (mainContent) {
                mainContent.classList.remove('code-panel-active');
            }
            document.body.classList.remove('code-panel-open');

            if (explorerPanel) {
                explorerPanel.style.right = '';
            }
        }

        window.closeCodePanel = closeCodePanel;

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Add click outside listener for model dropdown
            document.addEventListener('click', function(e) {
                const modelDropdown = document.getElementById('modelDropdown');
                const modelButton = document.getElementById('modelButton');

                if (modelDropdown && modelButton) {
                    if (!modelButton.contains(e.target) && !modelDropdown.contains(e.target)) {
                        modelDropdown.style.display = 'none';
                    }
                }
            });

            // Code panel resize functionality
            const codePanel = document.getElementById('codePanel');
            const resizeHandle = document.getElementById('codePanelResizeHandle');

            if (codePanel && resizeHandle) {
                let isResizing = false;
                let startX = 0;
                let startWidth = 0;

                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startWidth = codePanel.offsetWidth;
                    resizeHandle.classList.add('resizing');
                    document.body.style.cursor = 'ew-resize';
                    document.body.style.userSelect = 'none';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;

                    const deltaX = startX - e.clientX;
                    const newWidth = startWidth + deltaX;

                    const minWidth = 300;
                    const maxWidth = window.innerWidth * 0.8;

                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        codePanel.style.width = `${newWidth}px`;
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        resizeHandle.classList.remove('resizing');
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                    }
                });
            }
        });
    </script>
</body>
</html>
